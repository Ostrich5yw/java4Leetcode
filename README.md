# leetcodeworkspace
# leetcode问题：对于全局变量，每次一定要重新初始化，否则编译器多次测试时，会复用这个全局变量
# 3. 快慢指针+set数组
# 4. [1](二分法——寻找两个正序数组的中位数) 两个有序数组中找中位数
# 5. [1](动态规划——寻找最长子串) 动态方程：d[i][j] = d[i+1][j-1] & s[i] = s[j] 
# 6. [2](Z字形存储)，建立n行个字符串，依次按规律添加进对应字符串中
# 7. [2](整数反转)  判断是否越界，只需要依次翻转并判断n是否大于MAX_VALUE/10,最后一位翻转时判断n是否等于MAX_VALUE/10且最后一位>7或<-8
# 8. [2](字符串转换整数)   模式匹配
# 10. [1](动态规划——模式匹配) 
# 11. [1](左右双指针——寻找最大容积)   小的一边向内移动，直到left==right，记录到的最大的容积即为结果
# 12. [1](贪心——转罗马字符)  每次找当前数字可以匹配的最大字符 
# 15. [1](左右双指针——寻找三数之和)  固定一个数，另两个数采用左右双指针，寻找符合条件的值。采用先排序，后针对相同值跳过，实现去重
# 16. [1](左右双指针——寻找最接近三数之和)
# 17. [2](字符串拼接)    电话号码的字母组合
# 18. [1](左右双指针——寻找四数之和)
# 19. [1](快慢双指针(遍历链表)——删除倒数第n个数)   快指针比慢指针多走n+1步，然后开始一起向后遍历，快指针到末尾，慢指针刚好指向n-1  
# 20. [2](有效的括号)  字符匹配
# 22. [2](括号生成)  递归遍历
# 23. [1](分治法——合并K个升序链表)  两两合并，层层向上递归（go里面还用了一下多线程）
# 24. [1](快慢指针——两两交换链表中的节点)
# 25. [1](快慢指针——K个一组翻转链表)  206题的进化版，相当于多次调用206
# 206. [1](快慢指针——翻转链表)
# 26，27. [1](快慢指针——移除元素)  快指针做判断，慢指针做原地新数组的上界，每当快指针发现满足条件的数据时，将其添加到原地新数组nums[slow++]
# 28. [1](KMP算法——匹配子字符串)
# 29. [2](两数相除)   long处理溢出，异或^ 实现符号判别，移位实现除法
# 30. [2](串联所有单词的子串)   重点在于字典单词等长！！！利用一个map进行比较，map中记录字典中的单词及其出现次数，每当在子串中发现则将其-1，为-1或不在map中则是不匹配，继续向后查找
# 31. [2](***下一个排列***)  从后向前，找到正序结构(a[i] > a[i - 1]),将i-1与后半段中大于且最接近a[i-1] 的数与其交换，最后将i,length-1的数正序
# 32. [2](***最长有效括号***)    left，right分别记录左右括号的的值，正序逆序分别遍历一次。left==right时记录当前长度，left<right时归零当前长度(针对'())()'),同时需要逆序再次遍历(针对'(()')
# 33. [2](***搜索旋转排序数组***)    先遍历找到旋转位置，前数组为原数组后半部分，后数组为原数组前半部分，根据target大小选择在哪个数组进行二分查找
# 34. [1](二分查找——查找连续重复数字的左右边界)   通过两次二分查找分别查找左右边界，重点在于当mid==target时的判断。
# 36. [2](***有效的数独***)  构建3个9*9矩阵来判重。即9个9维的记录数组，分别记录0,1,2,3,4,5,6,7,8是否出现。注意判断出现在哪个3*3格子只需i/3*3 + j/3 
# 37. [1](DFS——解数独)   通过DFS递归+回溯每一个 '.' 位置上可能填入的数字，并通过36中的方法进行合法性判定
# 38. [2](***外观数列***)   
# 39. [1](DFS——组合总和)   注意Go数组和指针的用法！！！通过DFS递归+回溯找出一个数列中和为n的所有情况
# 40. [1](DFS——组合总和II)  数组排序后，通过DFS进行遍历，使用candidates[i] != candidates[i-1]去重
# 43. [2](***大数乘、大数加***)  乘需要按照竖式乘法，将num1的每一位与num2相乘(按位相乘，末尾追加num1当前位所在位数的0)，
#加法注意写法：while(point1>0||point2>0||mark>0){ t1=point1>0?num1[point1]:0  t2=point2>0?num2[point2]:0 res=三者之和%10 mark=三者之和/10}
# 45. [1](动态规划——跳跃游戏)  从后向前，如果可以跳到末尾则置为1，否则比较该位置可以跳到的几个位置，选出最小次数a，则该位置跳跃次数为a+1
# 46. [1](DFS——全排列)   找出给出数组的全部排列方式。用一个mark数组记录给出数组的使用情况，每一个DFS均对数组进行for循环遍历。
# 47. [1](DFS——全排列(有重复值))   通过 !(i > 0 && nums[i] == nums[i-1] && marks[i-1]) 进行去重，即对于1,1,2 按照索引0,1时，不会加入结果数组，结果(1,1,2)是按照索引1,0,2加入的
# 44. [2](通配符匹配)  两字符串，一个全字符，一个包含通配符
# 48. [2](旋转图像)   原地顺时针旋转矩阵——找规律，从最外圈到最内圈依次旋转
# 49. [2](字母异位词分组) 转为char[]数组进行排序，之后再转为String并结合Map进行分组。
# 50. [2](Pow计算幂函数)  倍乘，使用递归，每次aadN取2,4,8,16...个数进行累乘，直到aadN > n,则用n-addN并再次进入递归
# 51. [1](DFS——N皇后)  找出指定大小网格内所有合法的N皇后排列，使用DFS按行进行遍历，并判断合法列插入Queen
# 52. [1](DFS——N皇后)   返回上一题结果的size即可
# 54、59. [2](螺旋矩阵、顺时针打印矩阵) 使用全局变量way数组，配合变量n记录走的方向；nowX，nowY记录当前位置；并将走过的位置置为101，不可再走；当发现n，n+1都无路可走时，说明遍历完成，返回结果链表list。
# 55. [2](跳跃游戏) 由前至后遍历数组，maxPos记录我们当前可以到达的最远位置，并随着到达一个新节点不断更新maxPos，一旦无法到达当前结点i，结束遍历。
# 56. [2](合并区间) 合并所有重叠的区间，并返回一个不重叠的区间数组
# 57. [2](插入区间) 由前至后遍历，如果新区间与当前区间无交集且新区间大，则只插入当前区间；如果新区间与当前区间无交集且新区间小，说明新区间与原序列无交集，则插入二者；如果有交集，则更新新区间的范围，继续向后查找。

# 233. [2](数字1的个数)    分别计算个、十、百......千位上1出现的次数，再求和。
# 260. [1](位运算——只出现一次的数字)  所有数取异或得到两个单频数字的异或结果x，通过x&-x得到二者不相同的最低位，由此将原数组一分为二，分别包含两个单频数字，对两数组求异或，得到结果
# x & -x 可以得到x中，为1的最低位
正数的补码与原码相同。负数的补码的符号位为1，其余位为该数绝对值的原码按位取反，然后整个数加1。
正数之间：位运算是使用他们的原码进行；
只要有负数：负数使用补码进行运算，如果运算结果符号位为1，那么需要求运算结果的补码才是答案，如果运算结果符号位为0，那么答案就是运算结果。
# 264. [1](动态规划——丑数)  三个指针记录当前位置*2,3,5，最小的加入结果数组并对最小的一个或多个指针后移一位。
# 274、275. [1](二分查找——H指数) 
# 279. [1](动态规划——完全平方数)   寻找数字 n 可以由最少的完全平方数表示的个数  
# 287. [1](成环问题——寻找重复数)  类似于成环问题141,142  以重复数作为环入口，查找quick，slow相交点，再找到环入口
# 289. [1](DFS——原地变换矩阵)  在原矩阵基础上，原地将矩阵每个位置，根据该点周围8个点的原矩阵值转换为新值，使用2,3暂时代替本轮复活或死亡的元素，使其不参与之后元素判断的同时，在回溯时完成对其的原地转换。
# 295. [1](堆——数据流的中位数)  大小顶堆配合查询中位数；声明大顶堆存放较小的一半元素，堆顶存放上半区最大元素；小顶堆存放较大的一半元素，堆顶存放下半区最小元素；中位数即是二者均值。
# 297. [1](DFS——二叉树的序列化和反序列化)   使用DFS遍历树进行序列化，再使用DFS构造树，注意：使用左右子树返回值构造当前root节点更方便。
# 299. [2](猜数字游戏)   顺序遍历记录值、位置相等元素；Map记录值相等、位置不等元素，注意此处的Key可以为正负，即两个数组一个增key一个降key，不为0则说明存在条件元素。
# 300. [1](动态规划——最长递增子序列)   转移方程：dp[i] = Max(d[i], dp[j] +1)   且j满足 nums[j] < nums[i] 和 j < i
# 301. [1](BFS——删除无效括号)   题目要求求最小，即对应BFS。BFS基本是维护一新一旧两个数组，每次遍历旧数组所有元素并将状态更新到新数组。
# 303、304 [2](前缀和、区域和检索)   先将0-i(0<=i<=n)的和都存储于数组sum中，即到第i位之和==sum[i] i-j之和==sum[j]-sum[i-1]
# 306. [2](累加数)   判断一个字符串是否满足累加数。使用go语言中的strconv是否报错来判断数字是否越界；之后只需确定起始的两个数字A，B，并找到是否存在C=A+B,如果没有则跳出(使用A，B两数的位数确定C的位数在max(A,B)与max(A,B)+1之间)；有则执行A=B,B=C,继续向后遍历。
# 307. [1](线段树——区域和检索)   返回数组nums中索引left和索引right之间的nums元素的和 
# 309. [1](动态规划——最佳买卖股票时机含冷冻期|多转移方程)  涉及三个状态——买入、冷冻、卖出，所以需要三个数组分别对应三个状态转移方程。
# toOffer35. [2](复杂链表的复制)   使用Map记录新旧节点对应关系，再使用newNode.random = map.get(oldNode.random) 填补random指针
# toOffer53-I. [2](在排序数组中查找数字)   两次二分查找，查找子串的左右端点
# toOffer53-II. [2](0～n-1中缺失的数字)   用basic记录当前位置应该出现的数字，遍历数组每一位是否与basic一致，若全部一致，缺失的肯定是最后一位，即return nums.length
# toOffer50. [2](第一个只出现一次的字符)   使用Map记录字符首位置，重复的元素的value置为-1，遍历完成后，再次遍历Map，不为-1且value最小的即为第一个只出现一次的字符
# toOffer4. [2](二维数组中的查找||搜索二维矩阵)  从0行matrix[0].length-1开始查询，小于target则行++，大于target则列--
# toOffer32. [1](二叉树——层序遍历三种输出方式)   Z字形输出，分两类分别按左右、右左节点加入栈，再依次出栈并进入层次遍历队列即可实现
# toOffer26. [1](二叉树——树的子结构)   判断A树中是否存在与B完全一致的子树、
# toOffer28. [1](二叉树——对称的二叉树)   判断A树是否是一个对称的二叉树，recur(root.left,root.right) 判断now1.val==now2.val&&recur(now1.left,now2.right)&&recur(now1.right,now2.left) 
# toOffer46. [1](DFS——把数字翻译成字符串)    要求计算种类数，直接使用递归求解
# toOffer48. [1](快慢指针——最长不含重复字符的子字符串)   使用快慢指针构成滑动窗口，配合HashSet实现判重，当重复时quick不动，slow后移，直到无重复再出现，quick继续后移。
# toOffer42. [2](连续子数组的最大和)  计算最大子数组和，考虑第i位，如果前序和为负，则一定有nums[i] > nums[i] + sum；所以我们用sum记录当前数组和，如果sum<0，则抛弃前序数组，由当前位开始重新计算sum。
# toOffer47. [1](动态规划——礼物的最大价值)   转移方程：dp(i, j) = max{dp(i - 1, j), dp(i, j - 1)} + grid[i][j]。
# toOffer21. [1](双指针——调整数组顺序使奇数位于偶数前面)  使用left，right分别指向数组左右，分别搜索偶数与奇数，二者分别指向目标节点后，交换二者位置，直到 left>=right
# toOffer22. [1](双指针——链表中倒数第k个节点)  slow指针从首节点开始，quick指针向后移k位，当quick指向末尾，slow即指向倒数第k位
# toOffer52. [1](双指针——两个链表的第一个公共节点)  假设两链表长度分别为A和B，则有A+B=B+A,即分别用两指针从两链表头结点开始向后移动，分别到达末尾处后，则从开始链表的另一链表头结点重新开始向后移动，则二者必会在交点处相交
# toOffer57.  [1](双指针——和为s的两个数字)  使用slow记录其中一个结果数字，二分法在slow之后查找第二个结果数字
# toOffer58 - I. [1](双指针——翻转单词顺序)   slow记录每个单词起始位置，quick记录每个单词终止位置，遍历整个字符串
# toOffer12 [1](DFS——矩阵中的路径)    首先遍历数组找到起始位置，再使用dfs搜索符合题意的路径
# toOffer13 [1](DFS——机器人的运动范围)  使用mark数组记录当前位置是否被访问过，定义isLegal判断x,y是否越界是否被访问过并且是否符合题意，最后向右向下遍历矩阵：dfs(右)+dfs(下)+1
# toOffer34 [1](DFS——二叉树中和为某一值的路径)  搜索整个路径和为target的所有路径。list.add dfs(root.right||left, list, target - root.right.val); list.remove
# toOffer36 [1](DFS——二叉搜索树与双向链表)  引入一个新节点head记录递归的上一节点，和递归的当前节点root相互指向即可。head.right = root;root.left = head;head = head.right;
# toOffer54 [1](DFS——二叉搜索树的第k大节点)  以“先右再中再左”的顺序遍历树，遍历到“中”时k--，当k为0时，说明当前节点为第k大节点。
# toOffer41 [2](数据流中的中位数)  使用一个大顶堆一个小顶堆实现中位数求解，元素先进入大顶堆后进入小顶堆，且始终保证小顶堆元素个数小于大顶堆元素个数，最终二者的堆顶平均值或者大顶堆堆顶即是中位数。
# toOffer45 [2](把数组排成最小的数)   把数组里所有数字拼接起来排成一个数：先将整个int数组转化为String数组，重写String数组排序规则，按照(o1+o2).compareTo(o2+o1)由小到大排序，最后将String数组连接，形成返回结果。
# toOffer61 [2](扑克牌中的顺子)  只需要排序数组并求得0的数量，再判断0的个数是否可以填补顺序数组元素间的差值。
# toOffer55-I [1](DFS——二叉树的深度)  节点为nil则返回0，反之返回max(dfs(left),dfs(right))+1
# toOffer55-II [1](DFS——平衡二叉树)  在返回节点当前深度的基础上，返回当前子树是否为平衡二叉树。这样的好处是一旦发现一棵子树不是平衡二叉树，后续无需再计算，直接返回false。
# toOffer64 [1](DFS——求1+2+…+n)
# toOffer68-I [1](DFS——二叉搜索树的最近公共祖先)  递归判断p,q是否在root节点的左右，即是否有 p.val < root.val < q.val。
# toOffer68-II [1](DFS——二叉树的最近公共祖先)    找到目标节点返回true，否则返回false，某节点左右子树同时返回true或者root==p||q 且 一个子树返回true，则为最近父节点
# toOffer07 [1](DFS——重建二叉树) 根据前序遍历和中序遍历结果重建二叉树    先通过先序数组确定中间节点A，再进入中序数组找到A，将中序数组划分为左右两部分（即左右子树）
# 106       [1](DFS——重建二叉树) 根据后序遍历和中序遍历结果重建二叉树
# toOffer16 [1](分治——数值的整数次方)  以2的倍数累加乘积，即每次以tt=1,2,4…;nowN=1+2+4+8…个x相乘，当nowN +tt > n时，n-=nowN，nowN置0，tt置1，重新开始累加。
# toOffer33 [1](DFS——二叉搜索树的后序遍历序列) 后序遍历数组，中间节点在数组末尾，由于是二叉搜索树，因此每次只需从首位开始，查找连续的小于末尾元素的子数组作为左子树，查找连续的大于末尾元素的子数组作为右子树。如果左右子树元素之和刚好等于当前数组-1（即左右子树元素之和+根节点==当前数组元素之和），说明当前数组符合条件，继续遍历左右子树。
# toOffer15 [1](位运算——二进制中1的个数)  与1取&，之后再右移一位，直到数字为0
# toOffer65 [1](位运算——不用加减乘除做加法)  使用位运算实现加法   不考虑进位的情况下，1011+1001得到0110，1+1=0、1+0=1、0+0=0，正好符合异或运算；考虑进位时，1011+1001得到的是10010，只有相同位置都为1时才会有进位，正好符合位与运算再左移一位；
# toOffer56-I [1](位运算——数组中数字出现的次数)  除两个数字之外，其他数字都出现了两次。  使用异或运算找出两个数字的异或，再根据两数字某一二进制位不同（该位异或结果为1），将原数组一分为二，则两数字分别存在与两数组中，再次对两数组分别求异或即可
# toOffer56-II [1](位运算——数组中数字出现的次数II) 除一个数字只出现一次之外，其他数字都出现了三次   [3*(a+b+c) - (a+a+a+b+b+b+c)] / 2    
# toOffer39 [2](数组中出现次数超过一半的数字)  摩尔投票法，两相邻数组只要不同就相互抵消，最后剩下的一定是数量超过一半的目标元素。
# toOffer66 [2](构建乘积数组)  先从左至右得到每个元素的左半边之积，再从右至左得到每个元素的右半边之积。
# toOffer14 - I [2](剪绳子)    求剪的小段的最大乘积，尽可能剪多的3
# toOffer57 - II [1](双指针——滑动窗口，和为S的连续正数序列)    输出所有和为target的连续正整数序列，左右指针构成滑动窗口，寻找满足条件的子序列
# toOffer62 [2](圆圈中最后剩下的数字)    逆推目标元素，最终时刻目标元素的位置在0，即f(0)=0 有 f(n) = ( f(n - 1) + m ) % n   （m为移动步长，n为当前数组长度2->n） 
# toOffer20 [2](表示数值的字符串)   请实现一个函数用来判断字符串是否表示数值（包括整数和小数）
# toOffer29 [2](顺时针打印矩阵)    同54 59
# toOffer31 [2](栈的压入、弹出序列)  输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。根据弹出顺序模拟栈的动作
# toOffer67 [2](把字符串转换成整数)  写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
# toOffer59 - I [2](滑动窗口的最大值)      优先队列寻找窗口最大值
# toOffer59 - I [2](队列的最大值)     一个单调队列，每个元素入队时，都会踢出前面比它小的对内元素，以此保障队列始终单调递减
# toOffer37 [2](DFS——二叉树的序列化和反序列化)    深度遍历实现树–>字符串，如何生成一棵树（采用深度遍历，每一步新建root，并通过返回值给root.Left和root.Right赋值）
# toOffer38 [1](DFS——字符串的排列)    先为序列排序以实现去重，再使用DFS遍历所有情况
# toOffer19 [1](动态规划——正则表达式匹配) 
# toOffer49 [1](动态规划——丑数)       三指针：三指针指向的位置每次分别乘2,3,5，最小的乘积放入数组，对应指针向后一个
# toOffer60 [1](动态规划——n个骰子的点数) 令f(n,s)为二维矩阵，表示为n个骰子点数为s的情况；有f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)
# toOffer51 [1](递归分治——数组中的逆序对) 归并排序过程中，比较左右数组时，当左数组元素大，则记录其后的元素个数即为逆序对个数
# 735 [1](栈模拟——行星碰撞)    两种对立元素打架，应考虑到栈模拟
# 745 [1](字典树——前缀和后缀的搜索)    建立两个字典树分别记录前后缀，每个节点使用ArrayList记录所有经过这个点的字符串序号
# 558 [1](DFS——四叉树合并)   再难的递归问题，先写出来框架，public dfs{ if(终止条件)   for(遍历下一轮情况)dfs()   return 结果 }
# 731 [2](区间重叠问题)   用一个数组A记录所有的范围，一个数组B记录重复的范围，与A相交则加入B，与B相交说明已经存在3次，返回false    if(l < end && r > start)
# 1260 [2](二维网络迁移)  数组移动 
# 676 [1](字典树——递归进行查询)  实现一个魔法字典，情况太多所以使用递归搜索整个树。
# toOffer115 [1](拓扑排序——重建序列超序列)   拓扑排序使用Set[]数组记录每一个元素指向的若干个元素，使用recInNum记录每个节点被指向的此处，用队列遍历，每次加入recInNum==0的元素，再将他指向的元素，对应的recInNum减1  
# 676 [1](模拟——分数加减运算)    求最大公约数：递归gcd(a,b){gcd(b, a % b)} 
# 593 [1](模拟——判断是否为正方形)   只需要判断四条边相等并且两条对角线相等即可

# 29. 大数除 43. 大数乘，大数加  
# 34 用两边二分搜索找到元素起始和终止位置
# 39,40,46，79，90 深度搜索  
# 48 矩阵旋转
# 49 对String数组中的字符串分类
# 50 快速计算n次方
# 53 计算最大子序和（很帅的动态规划）
# 54 59 模拟矩阵输出与生成
# 56 合并相交区间(重写排序规则)
# 55 是否可以到达终点（贪心问题）
# 61 寻找移动后新的头结点（先把链表转为循环链表）
# 62,63,64 二维数组内寻找路径数（递归，使用数组记录，避免重复计算）（动态规划）
### 动态规划问题一定是从小到大，比如我一开始列的dp[i][j]=dp[i+1][j]+dp[i][j+1](即i，j到终点的路径数等于i+1,j和i，j+1到终点的路径数之和)
### 也就是说我将问题转化为了从大到小求解(显然这里dp[n][m]为最小，即0)
### 实际上应该是dp[i][j] = dp[i-1][j] + dp[i][j-1](即到达i，j的路径数等于到达i-1,j和i,j-1的路径数之和)（显然这里dp[0][i]和dp[j,0]最小，即1）
# 69 二分法实现平方根计算
# 71 字符串匹配问题。（论字符串拼接与substring的速度差距）
# 73 使用常数量额外空间对存在0的行列置0
# 75 双指针实现将大于a的数与小于a的数分别放在a两边（荷兰国旗问题）
# 77，78 深度遍历寻找所有可能的数字组合 VS 字典序 法，移位+位运算实现数字组合(89)
### '补充other/FindALLGroup（给一个数组，找出其所有组合（组合需按原数组顺序））'
# 79 路径搜索（DFS）
# 80 字符串删除重复字符
# 33，81 二分查找进阶，搜索一个旋转数组中是否存在指定值
# 82 快慢指针实现删除重复元素
# 86 链表中将大于x的放在后面，小于x的放在后面，同时不改变这两部分的原顺序(链表的截取与插入)
# 88 [1](两个不等长的数组都需要遍历到末尾，可采用||嵌套&&的方式进行遍历,注意是或者而不是且)
# 89 再一次考察移位+位运算，同时引入递归（涉及二进制运算要先观察目标数字生成规律）
# 90 DFS(注意剪枝操作)
# 91 动态规划（题目要求返回结果数量，应该想到动态规划）
# 92 利用[1](递归回溯)，只扫描一遍链表来旋转链表
# 93 递归查找所有满足题意的字符串划分形式
# 94 迭代实现二叉树中序遍历
# 95 递归生成所有类型的二叉搜索树[注意如何保存所有根节点，以往我会在递归完毕时，通过新建一个数组复制所有遍历数组值来保存一种情况](显然此题思路更好--动态生成所有节点)
###           List<Integer> temp = new ArrayList<>(existlist);
###           for (int i:existlist) {
###                temp.add(i);
###           }
###           res.add(temp);
# 96 动态规划计算生成二叉树个数，即某点的二叉树个数等于左右子树数量的笛卡尔积[1](列递推式时不要把递推变量与题目变量混淆，最好选择新的符号做递推变量)
# 98 中序遍历观察二叉树是否是排序二叉树，重点在于使用pre记录中序遍历上一节点的值

# 100, 101 不要总想着用一个节点进行递归，[1](这里我们使用左右两个指针同时递归左右子树，来检验是否左右相等或中心对称)
# 102,103 层序遍历二叉树 

# 105 根据中序，先序数组构建二叉树
# 106 根据中序，后序数组构建二叉树

# 109 链表生成平衡二叉树[1](快慢指针可以很好的实现链表确定范围的问题)

# 116 完全二叉树每个节点生成next指向它的右侧节点(左子树指向右子树，右子树指向root.next的左子树)
# 117 使用一个链表进行层次遍历，关键在于引入一个len记录当前链表长度，再往链表后面加子节点，我们对当前层只遍历len次即可

# 120 动态规划求最短路径[1](动态规划问题一定要将原问题翻转过来，比如这道题问从顶端到达底端的最短距离，我们引入数组matrix[i][j]表示的就是i,j到达顶端的距离)
# 125 比较字符串是否是回文串，我们使用Character.toLowerCase 来避免大小写和数字的判断
# 133 DFS 与 BFS 进行图的复制
# 136 [2](只出现一次的数字) 位运算 异或运算
# 137 [2](只出现一次的数字,其他数字出现三次) [3*(a+b+c) - (a+a+a+b+b+b+c)] / 2
# 141 [2](链表是否成环)  快慢指针 fast向后2，slow向后1，根据能否追上判断有无链表环 
# 142 [2](链表是否成环)  快慢指针，fast向后2，slow向后1，mark记录向后次数，追上时，通过mark+1即可得  环的长度。之后fast在head向后mark+1步，slow在head，fast追到slow时就是环起点
# 144 145 前序 后序迭代遍历[1](***************************)
# 147 直接插入排序 148 归并排序      ---均针对链表
# 150 逆波兰表达式，使用栈，每次遇到符号位时，对栈顶的两个值做相应运算
# 151 栈实现反转字符串中的单词序列
# 152 计算最大子序乘积（结合53题）这里需要同时维护一个
# 153 154 旋转后的升序数组，找最小值。使用二分法进行搜索[1](二分法通用模板while(left+1<right).退出后判断取值left||right,优势在于不用考虑mid+1&mid-1&mid的各个边界条件)
# 155 MinStack [1](加入一数据时，不仅存储该数据的val，同时一并存储当前整个数组的minVal；建立新的结构体arrayNum（int val；int minVal；）)
# 160 数学问题，两个指针分别由headA，headB开始绕环，一定会在交点相遇
# 164 [1](基数排序)
# 165 使用字符串直接进行分割后比较，或者使用双指针，配合n = n*10 + 下一位字符完成比较（这样做既无需比较.之后的0，并且还无需将所有字符拼成字符串后再转为int）
# 166 两数相除
# 168 [1](进制转换)1到26的26进制转化，由于A=1.....Z=26 不存在0，所以需要考虑按普通算法，有情况会造成第n位取A，n-1位取0；实际应该为第n-1位取Z。循环引入columnNumber --（使得1-26变为0-25）
# 169 [1](摩尔投票法)寻找众数，t从指向第一个开始，相同count+1，不同count-1。count减为零则t指向当前位置的下一位。最终指向的一定是众数
# 172 计算乘法末尾有多少个0，就是乘数中的因子一共包含多少个5
# 175 —— 178  180 ——185 196为SQL试题
# 179 精髓之处：有两个int a和b，如果我们希望比较ab大还是ba大，只需要将其拼接为字符串'ab'与'ba'直接比较[1](字符串比大小是按位比较ASCII码的大小)
# 187 输出所有长度为10且出现次数大于1的子串
# 189 [1](数组整体后移k位)  while(start<end){swap(nums[start++],nums[end--])}   依次由(0,n-1)(0,k-1)(k,n-1)调用while循环
# 190 [1](位运算)  与1相与可以求得一个数的最低位，配合新数左移+原数右移操作即可得到原数的逆转数  
# 191 [1](位运算)  与1相与可以求得一个数的最低位，配合原数右移操作即可得到为1的位个数
# 192 - 195 bash脚本
# 198 [1](动态规划)寻找间隔子数组中的最大值
# 199 层次遍历
# 200 递归寻找路径，发现所有被孤立的'1'[1](思路：遍历二维数组，一旦发现'1'，则进入递归寻找所有相邻1并全部置为'x'。遍历完成后，进入几次递归，就说明有几块相互隔绝的'1'群组)
# 201 left —— right内所有数字相与 == left 与 right的公共二进制前缀，并结合将前缀后续补0    如[5,7]  0101与0111  即是01结合00=0100  4 
# 202 [1](标准)取一个数字的每一位
# 203 [1](标准)遍历删除链表的某几个元素
# 204 寻找质数（从2开始遍历，去除2的所有倍数，去除3的所有倍数，4已被去除，继续向后遍历，去除5的所有倍数。。。剩余未去除的都是质数）
# 206 [1](标准)   反转链表，只需要三个指针分别指向连续的三个元素，前两个指针负责翻转，后一个指针负责记录当前位置。每一次交换后，三个指针同时向后移动一位
# 207 [1](拓扑排序) 利用二维数组que保存每一结点的所有前置结点，flag记录每一结点是否安全。DFS循环遍历所有路径
# 208 [1](前缀查询树) 利用struct{Trie[26];bool Endflag}存储录入的字符串，并判断字符串是否存在或是否为前缀
# 209 [1](快慢指针——滑动窗口) 通过滑动窗口查找数组内满足条件的最短子数组
# 211 同207,在基础上增加通配符'.'  (只需要对通配符节点遍历其26个子节点即可)
# 213 [1](本是线性查找，头尾相连后如何解决) 同198，只需在此基础上分为0-n-1与1-n两次查找即可
# 216 [1](标准)go指针与数组的完美示例
# 219 hashmap中只需要存放满足条件的最靠后元素(因为是向后遍历)，而无需存放满足条件的所有元素。
# 220 [1](滑动窗口，桶排序)滑动窗口：循环i向后一位，则删除一个之前存在桶中的第i-k元素。桶排序：根据特定条件将不同元素放入不同队列中(本题中用的是hashmap)
# 221 [1](动态规划)二维矩阵中查询最大矩形 dp[i][j] = Min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1   暴力算法，向右下遍历
# 222 [1](完全二叉树计算节点数) 
# 223 [1](计算两个随机矩形相交部分的面积) 
# 224 [1](加减法计算器) 展开所有括号，利用栈对符号进行存储 
# 225 [2](双队列实现栈) 新加元素放入A头，B数组拷贝至A，再将A数组整体拷贝至B
# 226 [2](经典问题) 翻转二叉树左右子树
# 227 [1](基本计算器)  计算加减乘除法
# 229 [1](摩尔投票法——加强版) 寻找个数大于1/3的数，即先通过摩尔投票找到个数最多的两个数，再判断其是否超过1/3
# 230 [1](寻找排序二叉树中第n小的值) 中序遍历，借助go多线程
# 231 [1](位运算) 判断一个数是否等于2的幂，位运算，n & n-1 ==0  则是，反之不是 
# 232 [2](双栈实现队列) A中元素出栈并压入B，将新元素压入B，将B中元素全部出栈并压入A
# 234 [2](链表是否回文)  快慢指针找到中心点，再依次比较前后元素
# 235 [2](搜索二叉树的最近公共祖先)  成立条件：两节点分别位于自己的两侧。 递归查找第一个符合条件的节点
# 236 [2](二叉树的最近公共祖先)  找到目标节点返回1，否则返回0，某节点左右子树同时返回1，则为最近父节点
# 238 [2](除自身以外数组的乘积)  使用left，right分别记录左右累乘积，每个位置分别相当于左边累乘 与 右边累乘的积
# 239 [2](记录滑动窗口最大值)  维护一个队列，队列元素由大到小排列，队头为窗口最大元素
# 240 [2](搜索二维矩阵)  搜索二维矩阵，查找目标元素
# 241 [1](递归分治)  以符号位分割为左右两部分，得到所有可能组合结果
# 242 [2](字母异位词)  s，t两个字符串用一个数组记录，s遇到+1，t遇到-1 最终为0则说明出现次数相同 
# 257 [2](寻找二叉树所有路径)  递归回溯
# 258 [2](各位循环累加直到小于10) 
# 263 [2](判断是否为丑数)
# 264 [2](寻找第n个丑数——堆与三指针)   堆：每次取出堆中最小的，乘以2,3,5 再形成新堆   三指针：三指针指向的位置每次分别乘2,3,5，最小的乘积放入数组，对应指针向后一个，  
# 268 [2](136转思路解决) 永远明确一个数字与自身相异或得0
# 274、275 [2](寻找H指数)  二分法
# 278 [2](寻找分界点)  二分法，mid=l+(n-l)/2   防止溢出(当n，l均超过int的一半，相加会溢出)
# 279 [1](动态规划)  查找一个数可以被分为最少多少个平方和的和
# 282 [1](递归回溯)   一串数字通过插入运算符，使其运算结果为指定值
# 284 [2](窥探迭代器)  迭代器的查看元素与后移指针是绑定操作(next)  我们希望只查看元素不后移指针(peek)  引入cache缓存处理
# 287 [2](找出重复数)  类似于成环问题141,142  查找quick，slow相交点，再找到环入口
# 289 [2](生命游戏——原地变换矩阵)  在原矩阵基础上，原地将矩阵每个位置，根据该点周围8个点的原矩阵值转换为新值
# 292 [2](Nim游戏)  每人每次拿1-3个，也就是说，如果给对手留下4的倍数个，则一定可以赢。所以return n%4!=0   即初始不为4的倍数，我们先手一定可以给对手留4的倍数个
# 295 [2](数据流中位数)  找到数据流中的中位数。通过一个大顶堆，一个小顶堆配合，大顶堆的堆顶小于小顶堆的堆顶，中位数即为大顶堆堆顶或者大小堆顶和/2
# 297 [2](树的序列化与反序列化) 深度遍历实现树-->字符串，如何生成一棵树（采用深度遍历，每一步新建root，并通过返回值给root.Left和root.Right赋值）
# 299 [2](猜数字游戏)  secret和guess两个数字，判断他们值一致但是位数不一致的数字个数bNum，使用一个map，map[secret]++ map[guess]--， bNum一定不是最后才求，而是随着遍历递增
# 300 [2](寻找最长递增子序列)  状态转移方程 dp[i] = max(dp[j]) + 1      (dp[j]<dp[i]   0<j<i)
# 301 [2](BFS解决删除最少括号，使括号合法)  每一轮迭代删除一个符号，并将其结果加入set数组，如果set中有合法值，立刻返回，即为删除最少情况下的合法值
# 303、304 [2](需要多次计算一维，二维数组n-m之和)   先将0-i(0<=i<=n)之和都存储与数组sum中，则0-i之和==sum[i] i-j之和==sum[j]-sum[i-1]
# 306 [2](累加数)  判断一个字符串是否符合前两个之和为第三个数   F(n)=F(n - 1)+F(n - 2)
# 309 [1](动态规划) 有多个维度（每一步有多个可能状态），即需要列出多个动态方程
# [1](多线程)
# 1114 使用信号量或原子类实现顺序操作